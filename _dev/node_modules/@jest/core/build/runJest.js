'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
<<<<<<< develop
exports.default = runJest;

function path() {
  const data = _interopRequireWildcard(require('path'));

  path = function() {
=======
exports.default = void 0;

function _path() {
  const data = _interopRequireDefault(require('path'));

  _path = function _path() {
>>>>>>> Move ui directory
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require('chalk'));

<<<<<<< develop
  _chalk = function() {
=======
  _chalk = function _chalk() {
>>>>>>> Move ui directory
    return data;
  };

  return data;
}

function _realpathNative() {
  const data = require('realpath-native');

<<<<<<< develop
  _realpathNative = function() {
=======
  _realpathNative = function _realpathNative() {
>>>>>>> Move ui directory
    return data;
  };

  return data;
}

function _console() {
  const data = require('@jest/console');

<<<<<<< develop
  _console = function() {
=======
  _console = function _console() {
>>>>>>> Move ui directory
    return data;
  };

  return data;
}

function _jestUtil() {
  const data = require('jest-util');

<<<<<<< develop
  _jestUtil = function() {
=======
  _jestUtil = function _jestUtil() {
>>>>>>> Move ui directory
    return data;
  };

  return data;
}

function _exit() {
  const data = _interopRequireDefault(require('exit'));

<<<<<<< develop
  _exit = function() {
=======
  _exit = function _exit() {
>>>>>>> Move ui directory
    return data;
  };

  return data;
}

<<<<<<< develop
function fs() {
  const data = _interopRequireWildcard(require('graceful-fs'));

  fs = function() {
=======
function _gracefulFs() {
  const data = _interopRequireDefault(require('graceful-fs'));

  _gracefulFs = function _gracefulFs() {
>>>>>>> Move ui directory
    return data;
  };

  return data;
}

function _jestWatcher() {
  const data = require('jest-watcher');

<<<<<<< develop
  _jestWatcher = function() {
=======
  _jestWatcher = function _jestWatcher() {
>>>>>>> Move ui directory
    return data;
  };

  return data;
}

function _testResult() {
  const data = require('@jest/test-result');

<<<<<<< develop
  _testResult = function() {
=======
  _testResult = function _testResult() {
>>>>>>> Move ui directory
    return data;
  };

  return data;
}

var _getNoTestsFoundMessage = _interopRequireDefault(
  require('./getNoTestsFoundMessage')
);

var _runGlobalHook = _interopRequireDefault(require('./runGlobalHook'));

var _SearchSource = _interopRequireDefault(require('./SearchSource'));

var _TestScheduler = _interopRequireDefault(require('./TestScheduler'));

var _collectHandles = _interopRequireDefault(require('./collectHandles'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}

<<<<<<< develop
function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();
  _getRequireWildcardCache = function() {
    return cache;
  };
  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
    return {default: obj};
  }
  var cache = _getRequireWildcardCache();
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(
          target,
          key,
          Object.getOwnPropertyDescriptor(source, key)
        );
      });
    }
=======
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(
        Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        })
      );
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
>>>>>>> Move ui directory
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

<<<<<<< develop
const getTestPaths = async (
  globalConfig,
  context,
  outputStream,
  changedFiles,
  jestHooks,
  filter
) => {
  const source = new _SearchSource.default(context);
  const data = await source.getTestPaths(globalConfig, changedFiles, filter);

  if (!data.tests.length && globalConfig.onlyChanged && data.noSCM) {
    new (_console().CustomConsole)(outputStream, outputStream).log(
      'Jest can only find uncommitted changed files in a git or hg ' +
        'repository. If you make your project a git or hg ' +
        'repository (`git init` or `hg init`), Jest will be able ' +
        'to only run tests related to files changed since the last ' +
        'commit.'
    );
  }

  const shouldTestArray = await Promise.all(
    data.tests.map(test =>
      jestHooks.shouldRunTestSuite({
        config: test.context.config,
        duration: test.duration,
        testPath: test.path
      })
    )
  );
  const filteredTests = data.tests.filter((_test, i) => shouldTestArray[i]);
  return _objectSpread({}, data, {
    allTests: filteredTests.length,
    tests: filteredTests
  });
};

const processResults = (runResults, options) => {
  const {
    outputFile,
    json: isJSON,
    onComplete,
    outputStream,
    testResultsProcessor,
    collectHandles
  } = options;
=======
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function() {
    var self = this,
      args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err);
      }
      _next(undefined);
    });
  };
}

const getTestPaths =
  /*#__PURE__*/
  (function() {
    var _ref = _asyncToGenerator(function*(
      globalConfig,
      context,
      outputStream,
      changedFiles,
      jestHooks,
      filter
    ) {
      const source = new _SearchSource.default(context);
      const data = yield source.getTestPaths(
        globalConfig,
        changedFiles,
        filter
      );

      if (!data.tests.length && globalConfig.onlyChanged && data.noSCM) {
        new (_console()).CustomConsole(outputStream, outputStream).log(
          'Jest can only find uncommitted changed files in a git or hg ' +
            'repository. If you make your project a git or hg ' +
            'repository (`git init` or `hg init`), Jest will be able ' +
            'to only run tests related to files changed since the last ' +
            'commit.'
        );
      }

      const shouldTestArray = yield Promise.all(
        data.tests.map(test =>
          jestHooks.shouldRunTestSuite({
            config: test.context.config,
            duration: test.duration,
            testPath: test.path
          })
        )
      );
      const filteredTests = data.tests.filter((_test, i) => shouldTestArray[i]);
      return _objectSpread({}, data, {
        allTests: filteredTests.length,
        tests: filteredTests
      });
    });

    return function getTestPaths(_x, _x2, _x3, _x4, _x5, _x6) {
      return _ref.apply(this, arguments);
    };
  })();

const processResults = (runResults, options) => {
  const outputFile = options.outputFile,
    isJSON = options.json,
    onComplete = options.onComplete,
    outputStream = options.outputStream,
    testResultsProcessor = options.testResultsProcessor,
    collectHandles = options.collectHandles;
>>>>>>> Move ui directory

  if (collectHandles) {
    runResults.openHandles = collectHandles();
  } else {
    runResults.openHandles = [];
  }

  if (testResultsProcessor) {
    runResults = require(testResultsProcessor)(runResults);
  }

  if (isJSON) {
    if (outputFile) {
      const cwd = (0, _realpathNative().sync)(process.cwd());
<<<<<<< develop
      const filePath = path().resolve(cwd, outputFile);
      fs().writeFileSync(
        filePath,
        JSON.stringify((0, _testResult().formatTestResults)(runResults))
      );
      outputStream.write(
        `Test results written to: ${path().relative(cwd, filePath)}\n`
      );
    } else {
      process.stdout.write(
        JSON.stringify((0, _testResult().formatTestResults)(runResults))
=======

      const filePath = _path().default.resolve(cwd, outputFile);

      _gracefulFs().default.writeFileSync(
        filePath,
        JSON.stringify((0, _jestUtil().formatTestResults)(runResults))
      );

      outputStream.write(
        `Test results written to: ${_path().default.relative(cwd, filePath)}\n`
      );
    } else {
      process.stdout.write(
        JSON.stringify((0, _jestUtil().formatTestResults)(runResults))
>>>>>>> Move ui directory
      );
    }
  }

  return onComplete && onComplete(runResults);
};

const testSchedulerContext = {
  firstRun: true,
  previousSuccess: true
};

<<<<<<< develop
async function runJest({
  contexts,
  globalConfig,
  outputStream,
  testWatcher,
  jestHooks = new (_jestWatcher().JestHook)().getEmitter(),
  startRun,
  changedFilesPromise,
  onComplete,
  failedTestsCache,
  filter
}) {
  const Sequencer = (0, _jestUtil().interopRequireDefault)(
    require(globalConfig.testSequencer)
  ).default;
  const sequencer = new Sequencer();
  let allTests = [];

  if (changedFilesPromise && globalConfig.watch) {
    const {repos} = await changedFilesPromise;
    const noSCM = Object.keys(repos).every(scm => repos[scm].size === 0);

    if (noSCM) {
      process.stderr.write(
        '\n' +
          _chalk().default.bold('--watch') +
          ' is not supported without git/hg, please use --watchAll ' +
          '\n'
      );
      (0, _exit().default)(1);
    }
  }

  const testRunData = await Promise.all(
    contexts.map(async context => {
      const matches = await getTestPaths(
        globalConfig,
        context,
        outputStream,
        changedFilesPromise && (await changedFilesPromise),
        jestHooks,
        filter
      );
      allTests = allTests.concat(matches.tests);
      return {
        context,
        matches
      };
    })
  );
  allTests = await sequencer.sort(allTests);

  if (globalConfig.listTests) {
    const testsPaths = Array.from(new Set(allTests.map(test => test.path)));

    if (globalConfig.json) {
      console.log(JSON.stringify(testsPaths));
    } else {
      console.log(testsPaths.join('\n'));
    }

    onComplete &&
      onComplete((0, _testResult().makeEmptyAggregatedTestResult)());
    return null;
  }

  if (globalConfig.onlyFailures && failedTestsCache) {
    allTests = failedTestsCache.filterTests(allTests);
    globalConfig = failedTestsCache.updateConfig(globalConfig);
  }

  const hasTests = allTests.length > 0;

  if (!hasTests) {
    const noTestsFoundMessage = (0, _getNoTestsFoundMessage.default)(
      testRunData,
      globalConfig
    );

    if (
      globalConfig.passWithNoTests ||
      globalConfig.findRelatedTests ||
      globalConfig.lastCommit ||
      globalConfig.onlyChanged
    ) {
      new (_console().CustomConsole)(outputStream, outputStream).log(
        noTestsFoundMessage
      );
    } else {
      new (_console().CustomConsole)(outputStream, outputStream).error(
        noTestsFoundMessage
      );
      (0, _exit().default)(1);
    }
  } else if (
    allTests.length === 1 &&
    globalConfig.silent !== true &&
    globalConfig.verbose !== false
  ) {
    const newConfig = _objectSpread({}, globalConfig, {
      verbose: true
    });

    globalConfig = Object.freeze(newConfig);
  }

  let collectHandles;

  if (globalConfig.detectOpenHandles) {
    collectHandles = (0, _collectHandles.default)();
  }

  if (hasTests) {
    await (0, _runGlobalHook.default)({
      allTests,
      globalConfig,
      moduleName: 'globalSetup'
    });
  }

  if (changedFilesPromise) {
    testSchedulerContext.changedFiles = (
      await changedFilesPromise
    ).changedFiles;
  }

  const results = await new _TestScheduler.default(
    globalConfig,
    {
      startRun
    },
    testSchedulerContext
  ).scheduleTests(allTests, testWatcher);
  sequencer.cacheResults(allTests, results);

  if (hasTests) {
    await (0, _runGlobalHook.default)({
      allTests,
      globalConfig,
      moduleName: 'globalTeardown'
    });
  }

  return processResults(results, {
    collectHandles,
    json: globalConfig.json,
    onComplete,
    outputFile: globalConfig.outputFile,
    outputStream,
    testResultsProcessor: globalConfig.testResultsProcessor
  });
}
=======
var _default =
  /*#__PURE__*/
  (function() {
    var _runJest = _asyncToGenerator(function*({
      contexts,
      globalConfig,
      outputStream,
      testWatcher,
      jestHooks = new (_jestWatcher()).JestHook().getEmitter(),
      startRun,
      changedFilesPromise,
      onComplete,
      failedTestsCache,
      filter
    }) {
      const Sequencer = (0, _jestUtil().interopRequireDefault)(
        require(globalConfig.testSequencer)
      ).default;
      const sequencer = new Sequencer();
      let allTests = [];

      if (changedFilesPromise && globalConfig.watch) {
        const _ref2 = yield changedFilesPromise,
          repos = _ref2.repos;

        const noSCM = Object.keys(repos).every(scm => repos[scm].size === 0);

        if (noSCM) {
          process.stderr.write(
            '\n' +
              _chalk().default.bold('--watch') +
              ' is not supported without git/hg, please use --watchAll ' +
              '\n'
          );
          (0, _exit().default)(1);
        }
      }

      const testRunData = yield Promise.all(
        contexts.map(
          /*#__PURE__*/
          (function() {
            var _ref3 = _asyncToGenerator(function*(context) {
              const matches = yield getTestPaths(
                globalConfig,
                context,
                outputStream,
                changedFilesPromise && (yield changedFilesPromise),
                jestHooks,
                filter
              );
              allTests = allTests.concat(matches.tests);
              return {
                context,
                matches
              };
            });

            return function(_x8) {
              return _ref3.apply(this, arguments);
            };
          })()
        )
      );
      allTests = yield sequencer.sort(allTests);

      if (globalConfig.listTests) {
        const testsPaths = Array.from(new Set(allTests.map(test => test.path)));

        if (globalConfig.json) {
          console.log(JSON.stringify(testsPaths));
        } else {
          console.log(testsPaths.join('\n'));
        }

        onComplete &&
          onComplete((0, _testResult().makeEmptyAggregatedTestResult)());
        return null;
      }

      if (globalConfig.onlyFailures && failedTestsCache) {
        allTests = failedTestsCache.filterTests(allTests);
        globalConfig = failedTestsCache.updateConfig(globalConfig);
      }

      const hasTests = allTests.length > 0;

      if (!hasTests) {
        const noTestsFoundMessage = (0, _getNoTestsFoundMessage.default)(
          testRunData,
          globalConfig
        );

        if (
          globalConfig.passWithNoTests ||
          globalConfig.findRelatedTests ||
          globalConfig.lastCommit ||
          globalConfig.onlyChanged
        ) {
          new (_console()).CustomConsole(outputStream, outputStream).log(
            noTestsFoundMessage
          );
        } else {
          new (_console()).CustomConsole(outputStream, outputStream).error(
            noTestsFoundMessage
          );
          (0, _exit().default)(1);
        }
      } else if (
        allTests.length === 1 &&
        globalConfig.silent !== true &&
        globalConfig.verbose !== false
      ) {
        const newConfig = _objectSpread({}, globalConfig, {
          verbose: true
        });

        globalConfig = Object.freeze(newConfig);
      }

      let collectHandles;

      if (globalConfig.detectOpenHandles) {
        collectHandles = (0, _collectHandles.default)();
      }

      if (hasTests) {
        yield (0, _runGlobalHook.default)({
          allTests,
          globalConfig,
          moduleName: 'globalSetup'
        });
      }

      if (changedFilesPromise) {
        testSchedulerContext.changedFiles = (yield changedFilesPromise).changedFiles;
      }

      const results = yield new _TestScheduler.default(
        globalConfig,
        {
          startRun
        },
        testSchedulerContext
      ).scheduleTests(allTests, testWatcher);
      sequencer.cacheResults(allTests, results);

      if (hasTests) {
        yield (0, _runGlobalHook.default)({
          allTests,
          globalConfig,
          moduleName: 'globalTeardown'
        });
      }

      return processResults(results, {
        collectHandles,
        json: globalConfig.json,
        onComplete,
        outputFile: globalConfig.outputFile,
        outputStream,
        testResultsProcessor: globalConfig.testResultsProcessor
      });
    });

    function runJest(_x7) {
      return _runJest.apply(this, arguments);
    }

    return runJest;
  })();

exports.default = _default;
>>>>>>> Move ui directory
